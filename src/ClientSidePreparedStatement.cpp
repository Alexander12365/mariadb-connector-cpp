/************************************************************************************
   Copyright (C) 2020 MariaDB Corporation AB

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with this library; if not see <http://www.gnu.org/licenses>
   or write to the Free Software Foundation, Inc.,
   51 Franklin St., Fifth Floor, Boston, MA 02110, USA
*************************************************************************************/


#include "ClientSidePreparedStatement.h"
#include "logger/LoggerFactory.h"
//#include "BasePrepareStatement.h"

namespace sql
{
namespace mariadb
{
  const Shared::Logger ClientSidePreparedStatement::logger= LoggerFactory::getLogger(typeid(ClientSidePreparedStatement));
  /**
    * Constructor.
    *
    * @param connection connection
    * @param sql sql query
    * @param resultSetScrollType one of the following <code>ResultSet</code> constants: <code>
    *     ResultSet.TYPE_FORWARD_ONLY</code>, <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or
    *     <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>
    * @param resultSetConcurrency a concurrency type; one of <code>ResultSet.CONCUR_READ_ONLY</code>
    *     or <code>ResultSet.CONCUR_UPDATABLE</code>
    * @param autoGeneratedKeys a flag indicating whether auto-generated keys should be returned; one
    *     of <code>Statement.RETURN_GENERATED_KEYS</code> or <code>Statement.NO_GENERATED_KEYS</code>
    * @throws SQLException exception
    */
  ClientSidePreparedStatement::ClientSidePreparedStatement(MariaDbConnection* connection, const SQLString& sql,
    int32_t resultSetScrollType,
    int32_t resultSetConcurrency,
    int32_t autoGeneratedKeys)
    : BasePrepareStatement(connection, resultSetScrollType, resultSetConcurrency, autoGeneratedKeys),
      sqlQuery(sql)
  {
    if (options->rewriteBatchedStatements) {
      prepareResult= ClientPrepareResult::rewritableParts(sqlQuery, protocol.noBackslashEscapes());
    }
    else {
      prepareResult= ClientPrepareResult::parameterParts(sqlQuery, protocol.noBackslashEscapes());
    }
    parameters= new ParameterHolder[prepareResult.getParamCount()];
  }

  /**
    * Clone statement.
    *
    * @param connection connection
    * @return Clone statement.
    * @throws CloneNotSupportedException if any error occur.
    */
  ClientSidePreparedStatement ClientSidePreparedStatement::clone(MariaDbConnection* connection)
  {
    ClientSidePreparedStatement clone =(ClientSidePreparedStatement)super.clone(connection);
    clone.sqlQuery= sqlQuery;
    clone.prepareResult= prepareResult;
    clone.parameters= new ParameterHolder[prepareResult.getParamCount()];
    clone.resultSetMetaData= resultSetMetaData;
    clone.parameterMetaData= parameterMetaData;
    return clone;
  }

  /**
    * Executes the SQL statement in this <code>PreparedStatement</code> object, which may be any kind
    * of SQL statement. Some prepared statements return multiple results; the <code>execute</code>
    * method handles these complex statements as well as the simpler form of statements handled by
    * the methods <code>executeQuery</code> and <code>executeUpdate</code>. <br>
    * The <code>execute</code> method returns a <code>boolean</code> to indicate the form of the
    * first result. You must call either the method <code>getResultSet</code> or <code>getUpdateCount
    * </code> to retrieve the result; you must call <code>getInternalMoreResults</code> to move to
    * any subsequent result(s).
    *
    * @return <code>true</code> if the first result is a <code>ResultSet</code> object; <code>false
    *     </code> if the first result is an update count or there is no result
    * @throws SQLException if a database access error occurs; this method is called on a closed
    *     <code>PreparedStatement</code> or an argument is supplied to this method
    * @see Statement#execute
    * @see Statement#getResultSet
    * @see Statement#getUpdateCount
    * @see Statement#getMoreResults
    */
  bool ClientSidePreparedStatement::execute()
  {
    return executeInternal(getFetchSize());
  }

  /**
    * Executes the SQL query in this <code>PreparedStatement</code> object and returns the <code>
    * ResultSet</code> object generated by the query.
    *
    * @return a <code>ResultSet</code> object that contains the data produced by the query; never
    *     <code>null</code>
    * @throws SQLException if a database access error occurs; this method is called on a closed
    *     <code>PreparedStatement</code> or the SQL statement does not return a <code>ResultSet
    *     </code> object
    */
  ResultSet* ClientSidePreparedStatement::executeQuery()
  {
    if (execute()) {
      return results->getResultSet();
    }
    return SelectResultSet::createEmptyResultSet();
  }

  /**
    * Executes the SQL statement in this <code>PreparedStatement</code> object, which must be an SQL
    * Data Manipulation Language (DML) statement, such as <code>INSERT</code>, <code>UPDATE</code> or
    * <code>DELETE</code>; or an SQL statement that returns nothing, such as a DDL statement.
    *
    * @return either (1) the row count for SQL Data Manipulation Language (DML) statements or (2) 0
    *     for SQL statements that return nothing
    * @throws SQLException if a database access error occurs; this method is called on a closed
    *     <code>PreparedStatement</code> or the SQL statement returns a <code>ResultSet</code> object
    */
  int32_t ClientSidePreparedStatement::executeUpdate()
  {
    if (execute()) {
      return 0;
    }
    return getUpdateCount();
  }

  bool ClientSidePreparedStatement::executeInternal(int32_t fetchSize)
  {


    for (int32_t i= 0; i <prepareResult.getParamCount(); i++) {
      if (parameters[i]/*.empty() == true*/) {
        logger.error("Parameter at position {} is not set", (i +1));
        ExceptionMapper::throwException(
          new SQLException("Parameter at position "+(i +1)+" is not set", "07004"),
          connection,
          this);
      }
    }

    std::lock_guard<std::mutex> localScopeLock(lock);
    try {
      executeQueryPrologue(false);
      results =
        new Results(
          this,
          fetchSize,
          false,
          1,
          false,
          resultSetScrollType,
          resultSetConcurrency,
          autoGeneratedKeys,
          protocol.getAutoIncrementIncrement(),
          sqlQuery,
          parameters);
      if (queryTimeout !=0 &&canUseServerTimeout) {

        protocol.executeQuery(
          protocol.isMasterConnection(), results, prepareResult, parameters, queryTimeout);
      }
      else {
        protocol.executeQuery(protocol.isMasterConnection(), results, prepareResult, parameters);
      }
      results->commandEnd();
      return results->getResultSet()/*.empty() == true*/;

    }
    catch (SQLException& exception) {
      if (results/*.empty() == true*/) {
        results->commandEnd();
      }
      throw executeExceptionEpilogue(exception);
    }/* TODO: something with the finally was once here */ {
      executeEpilogue();
      lock.unlock();
    }
  }

  /**
    * Adds a set of parameters to this <code>PreparedStatement</code> object's batch of send. <br>
    * <br>
    *
    * @throws SQLException if a database access error occurs or this method is called on a closed
    *     <code>PreparedStatement</code>
    * @see Statement#addBatch
    * @since 1.2
    */
  void ClientSidePreparedStatement::addBatch()
  {
    ParameterHolder[] holder= new ParameterHolder[prepareResult.getParamCount()];
    for (int32_t i= 0; i <holder.length; i++) {
      holder[i] =parameters[i];
      if (holder[i]/*.empty() == true*/) {
        logger.error(
          "You need to set exactly "
          +prepareResult.getParamCount()
          +" parameters on the prepared statement");
        throw ExceptionMapper::getSqlException(
          "You need to set exactly "
          +prepareResult.getParamCount()
          +" parameters on the prepared statement");
      }
    }
    parameterList.push_back(holder);
  }

  void ClientSidePreparedStatement::addBatch(const SQLString& sql)
  {
    throw SQLException("Cannot do addBatch(SQLString) on preparedStatement");
  }

  void ClientSidePreparedStatement::clearBatch()
  {
    parameterList.clear();
    hasLongData= false;
    this->parameters= new ParameterHolder[prepareResult.getParamCount()];
  }

  /** {inheritdoc}. */
  int32_t* ClientSidePreparedStatement::executeBatch()
  {
    checkClose();
    int32_t size= parameterList.size();
    if (size ==0) {
      return new int32_t[0];
    }

    std::lock_guard<std::mutex> localScopeLock(*lock);
    try {
      executeInternalBatch(size);
      results->commandEnd();
      return results->getCmdInformation()->getUpdateCounts();

    }
    catch (SQLException& sqle) {
      executeBatchEpilogue();
      throw executeBatchExceptionEpilogue(sqle, size);
    }
    executeBatchEpilogue();
  }

  /**
    * Non JDBC : Permit to retrieve server update counts when using option rewriteBatchedStatements.
    *
    * @return an array of update counts containing one element for each command in the batch. The
    *     elements of the array are ordered according to the order in which commands were added to
    *     the batch.
    */
  sql::Ints* ClientSidePreparedStatement::getServerUpdateCounts()
  {
    if (results/*.empty() != true*/ &&results->getCmdInformation()/*.empty() != true*/) {
      return results->getCmdInformation().getServerUpdateCounts();
    }
    return new int32_t[0];
  }

  /**
    * Execute batch, like executeBatch(), with returning results with long[]. For when row count may
    * exceed Integer.MAX_VALUE.
    *
    * @return an array of update counts (one element for each command in the batch)
    * @throws SQLException if a database error occur.
    */
  sql::Longs* ClientSidePreparedStatement::executeLargeBatch()
  {
    checkClose();
    int32_t size= parameterList.size();
    if (size ==0) {
      return new sql::Longs();
    }

    std::lock_guard<std::mutex> localScopeLock(lock);
    try {
      executeInternalBatch(size);
      results->commandEnd();
      return results->getCmdInformation()->getLargeUpdateCounts();
    }
    catch (SQLException& sqle) {
      throw executeBatchExceptionEpilogue(sqle, size);
    }/* TODO: something with the finally was once here */ {
      executeBatchEpilogue();
    }
  }

  /**
    * Choose better way to execute queries according to query and options.
    *
    * @param size parameters number
    * @throws SQLException if any error occur
    */
  void ClientSidePreparedStatement::executeInternalBatch(int32_t size)
  {
    executeQueryPrologue(true);
    results =
      new Results(
        this,
        0,
        true,
        size,
        false,
        resultSetScrollType,
        resultSetConcurrency,
        autoGeneratedKeys,
        protocol.getAutoIncrementIncrement(),
        NULL,
        NULL);
    if (protocol->executeBatchClient(
      protocol->isMasterConnection(), results, prepareResult, parameterList, hasLongData)) {
      return;
    }


    SQLException exception= NULL;

    if (queryTimeout >0) {
      for (int32_t batchQueriesCount= 0; batchQueriesCount <size; batchQueriesCount++) {
        protocol.stopIfInterrupted();
        try {
          protocol.executeQuery(
            protocol.isMasterConnection(),
            results,
            prepareResult,
            parameterList.get(batchQueriesCount));
        }
        catch (SQLException& e) {
          if (options.continueBatchOnError) {
            exception= e;
          }
          else {
            throw e;
          }
        }
      }

    }
    else {
      for (int32_t batchQueriesCount= 0; batchQueriesCount <size; batchQueriesCount++) {
        try {
          protocol.executeQuery(
            protocol.isMasterConnection(),
            results,
            prepareResult,
            parameterList.get(batchQueriesCount));
        }
        catch (SQLException& e) {
          if (options.continueBatchOnError) {
            exception= e;
          }
          else {
            throw e;
          }
        }
      }
    }
    if (exception/*.empty() != true*/) {
      throw exception;
    }
  }

  /**
    * Retrieves a <code>ResultSetMetaData</code> object that contains information about the columns
    * of the <code>ResultSet</code> object that will be returned when this <code>PreparedStatement
    * </code> object is executed. <br>
    * Because a <code>PreparedStatement</code> object is precompiled, it is possible to know about
    * the <code>ResultSet</code> object that it will return without having to execute it.
    * Consequently, it is possible to invoke the method <code>getMetaData</code> on a <code>
    * PreparedStatement</code> object rather than waiting to execute it and then invoking the <code>
    * ResultSet.getMetaData</code> method on the <code>ResultSet</code> object that is returned.
    *
    * @return the description of a <code>ResultSet</code> object's columns or <code>null</code> if
    *     the driver cannot return a <code>ResultSetMetaData</code> object
    * @throws SQLException if a database access error occurs or this method is called on a closed
    *     <code>PreparedStatement</code>
    */
  sql::ResultSetMetaData* ClientSidePreparedStatement::getMetaData()
  {
    checkClose();
    ResultSet* rs= getResultSet();
    if (rs/*.empty() != true*/) {
      return rs->getMetaData();
    }
    if (resultSetMetaData/*.empty() != true*/) {
      loadParametersData();
    }
    return resultSetMetaData;
  }

  /**
    * Set parameter.
    *
    * @param parameterIndex index
    * @param holder parameter holder
    * @throws SQLException if index position doesn't correspond to query parameters
    */
  void ClientSidePreparedStatement::setParameter(int32_t parameterIndex, const ParameterHolder& holder)
  {
    if (parameterIndex >=1 &&parameterIndex <prepareResult.getParamCount()+1) {
      parameters[parameterIndex -1] =holder;
    }
    else {
      SQLString error =
        "Could not set parameter at position "
        +parameterIndex
        +" (values was "
        +holder.toString()
        +")\n"
        +"Query - conn:"
        +protocol.getServerThreadId()
        +"("
        +(protocol.isMasterConnection() ? "M" : "S")
        +") ";

      if (options.maxQuerySizeToLog >0) {
        error +=" - \"";
        if (sqlQuery.size()<options.maxQuerySizeToLog) {
          error +=sqlQuery;
        }
        else {
          error +=sqlQuery.substr(0, options.maxQuerySizeToLog)+"...";
        }
        error +="\"";
      }
      else {
        error +=" - \""+sqlQuery +"\"";
      }

      logger.error(error);
      throw ExceptionMapper::getSqlException(error);
    }
  }

  /**
    * Retrieves the number, types and properties of this <code>PreparedStatement</code> object's
    * parameters.
    *
    * @return a <code>ParameterMetaData</code> object that contains information about the number,
    *     types and properties for each parameter marker of this <code>PreparedStatement</code>
    *     object
    * @throws SQLException if a database access error occurs or this method is called on a closed
    *     <code>PreparedStatement</code>
    * @see ParameterMetaData
    * @since 1.4
    */
  ParameterMetaData* ClientSidePreparedStatement::getParameterMetaData()
  {
    checkClose();
    if (!parameterMetaData) {
      loadParametersData();
    }
    return *parameterMetaData;
  }

  void ClientSidePreparedStatement::loadParametersData()
  {
    try (ServerSidePreparedStatement ssps =
      new ServerSidePreparedStatement(
        connection,
        sqlQuery,
        ResultSet::TYPE_SCROLL_INSENSITIVE,
        ResultSet::CONCUR_READ_ONLY,
        Statement::NO_GENERATED_KEYS)) {
      resultSetMetaData= ssps.getMetaData();
      parameterMetaData= ssps.getParameterMetaData();
    }
    catch (SQLSyntaxErrorException& sqlSyntaxErrorException) {

      throw sqlSyntaxErrorException;
    }
    catch (SQLSyntaxErrorException& sqlSyntaxErrorException) {
      parameterMetaData= new MariaDbParameterMetaData(NULL);
    }
  }

  /**
    * Clears the current parameter values immediately.
    *
    * <p>In general, parameter values remain in force for repeated use of a statement. Setting a
    * parameter value automatically clears its previous value. However, in some cases it is useful to
    * immediately release the resources used by the current parameter values; this can be done by
    * calling the method <code>clearParameters</code>.
    */
  void ClientSidePreparedStatement::clearParameters()
  {
    parameters= new ParameterHolder[prepareResult.getParamCount()];
  }

  void ClientSidePreparedStatement::close()
  {
    super.close();
    if (connection/*.empty() == true*/
      ||connection->pooledConnection/*.empty() == true*/
      ||connection->pooledConnection.noStmtEventListeners()) {
      return;
    }
    connection->pooledConnection.fireStatementClosed(this);
    connection= NULL;
  }

  int32_t ClientSidePreparedStatement::getParameterCount()
  {
    return prepareResult.getParamCount();
  }

  SQLString ClientSidePreparedStatement::toString()
  {
    SQLString sb("sql : '"+sqlQuery +"'");
    sb.append(", parameters : [");
    for (int32_t i= 0; i <parameters.length; i++) {
      ParameterHolder holder= parameters[i];
      if (holder/*.empty() == true*/) {
        sb.append("NULL");
      }
      else {
        sb.append(holder.toString());
      }
      if (i !=parameters.length -1) {
        sb.append(",");
      }
    }
    sb.append("]");
    return sb;
  }

  ClientPrepareResult ClientSidePreparedStatement::getPrepareResult()
  {
    return prepareResult;
  }
}
}
